# 多线程

线程实现的方式

## 实现Runnable接口

```java
public class Test implements Runnable {
    private String name;
    public Test(String name){
        this.name = name;
    }
    public static void main(String[] args) {
        Test test1 = new Test("线程A");
        Test test2 = new Test("线程B");
        Thread t1 = new Thread(test1);
        Thread t2 = new Thread(test2);
        t1.start();
        t2.start();
    }
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(name + "运行, i = " + i);
        }
    }
}
```

## 继承Thread类

```java
public class Test extends Thread {
    private String name;
    public Test(String name){
        this.name = name;
    }
    @Override
    public void run(){
        for (int i = 0; i < 10; i++) {
            System.out.println(name + "运行, i = " + i);
        }
    }
    public static void main(String[] args) {
        Test test1 = new Test("线程A");
        Test test2 = new Test("线程B");
        test1.start();
        test2.start();
    }
}
```

## Thread类和Runnable接口

```public class Thread extends Object implements Runnable```

`Thread`类是Runnable接口的子类，但是在Thread类中并没有完全实现Runnable接口中的run（）方法。

```java
Private Runnable target；
public Thread(Runnable target,String name){
    init(null,target,name,0);
}
private void init(ThreadGroup g,Runnable target,String name,long stackSize){
    ...
    this.target=target;
}
public void run(){
    if(target!=null){
        target.run();
    }
}
```

从定义中可以发现，在 Thread 类中的 run() 方法调用的是 Runnable 接口中的 run() 方法，也就是说此方法是由 Runnable 子类完成的，**所以如果要通过继承 Thread 类实现多线程，则必须覆写 run()。**

- 如果一个类继承Thread类，则不适合于多个线程共享资源。
- 实现了Runnable接口，则可以方便的实现资源的共享。

## 线程的状态变化

必须在主线程中创建新的线程对象。任何线程一般具有5种状态，即**创建，就绪，运行，阻塞，终止**。

- 创建状态

在程序中用构造方法创建一个线程对象后，此时它已经有了相应的内存空间和其他资源，但是还处于不可运行状态。 例如：`Thread thread = new Thread()`。

- 就绪状态

新建线程对象后，调用该线程的`start()`方法就可以启动线程。当线程启动时，线程进入就绪状态。线程将进入线程队列排队，等待CPU服务。

- 运行状态

当就绪状态被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run（）方法。run（）方法定义该线程的操作和功能。

- 阻塞状态

一个正在执行的线程在某个特殊状态下，如被人为挂起或者需要执行耗时的输入/输出操作，会让CPU暂时中止自己的执行。在可执行状态下，如果调用sleep(),suspend(),wait()等方法，线程都会进入阻塞状态。

- 死亡状态

线程调用stop()方法或者run（）方法执行结束后，即处于死亡状态。

## 线程的操作方式

#### 线程的强制运行

join（）

#### 线程的休眠

sleep（）

#### 中断线程

interrupt（）

#### 后台线程

setDaemon()  守护线程

#### 线程的优先级

```java
setPriority(Thread.MIN_PRIORITY)
setPriority(Thread.MAX_PRIORITY)
setPriority(Thread.NORM_PRIORITY)
```

#### 线程的礼让

yield（）将一个现成的操作暂时让给其他线程执行

### 同步以及死锁

#### 同步代码块

```java
synchronized(同步对象){
    需要同步的代码
}
```

#### 同步方法

```java
synchronized 方法返回值  方法名称(参数列表){
    
}
```

#### 死锁

所谓死锁，就是两个线程都在等待对方先完成，造成程序的停滞，一般程序的死锁都是在程序运行时出现的。

## Callable

callable和runnable的区别是callable可以有返回值，也可以抛出异常。







## 线程间定制化通信

启动三个线程：

AA打印5次，BB打印10次，CC打印15次

进行10轮。

## Synchronized同步

Synchronized的作用（三个）：

1） 原子性：确保线程互斥的访问同步代码；

2） 可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “**对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值**” 来保证的；

3） 有序性： 有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”；



三种用法：

1）作用在实例方法时，便是对象实例（this）；

2） 作用于静态方法时，便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；

3） 当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；

### 同步原理







