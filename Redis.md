## 六大数据结构

### 字符串sds

![image-20210923213945601](E:\实习\Java_docs\pics\image-20210923213945601.png)

SDS和C语言的区别：

1. SDS用len表示数组长度，可以以常数复杂度获得字符串长度。
2. 杜绝缓冲区溢出，当SDS对字符串修改时，会判断当前空间是否足够，不足够会自动扩展。
3. 减少了修改字符串带来的内存重分配次数，通过free属性实现空间预分配和惰性空间释放。
4. 二进制安全，因为是通过len判断字符串的长度。

### 链表

链表节点：双端队列

```c++
typedef struct listNode {
        //指向前一个节点
    struct listNode *prev;
    //指向后一个节点
    struct listNode *next;
   //值
    void *value;
} listNode;
```

链表结构：

```c++
typedef struct list {
	listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```

![image-20210923215303993](E:\实习\Java_docs\pics\image-20210923215303993.png)

### 字典

Redis的字典使用哈希表作为底层实现，一个哈希表中有多个哈希表节点，每个哈希表节点就是字典中的一个键值对。

哈希表：

```c++
typedef struct dictht {

    //桶
    dictEntry **table;

    //指针数组大小
    unsigned long size;

    //指针数组掩码，用于计算索引值
    unsigned long sizemask;

    //hash表现有节点数量
    unsigned long used;
} dictht;
```

![image-20210923215957735](E:\实习\Java_docs\pics\image-20210923215957735.png)

key表示键，v表示值，可以有多种类型，next表示指向下一个哈希表节点的指针，用于解决哈希冲突。

字典：

```c++
typedef struct dict {
    //类型处理函数
    dictType *type;
    //类型处理函数私有值
    void *privdata;
    //两个hash表
    dictht ht[2];
    //rehash标示，为－1表示不在rehash，不为0表示正在rehash的桶
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
    //当前正在运行的安全迭代器数量
    int iterators; /* number of iterators currently running */
} dict;
```

![image-20210923220223415](E:\实习\Java_docs\pics\image-20210923220223415.png)

- ht属性包含两个数组，两个都是哈希表，使用ht[0]存储数据，ht[1]用于rehashde 的时候用。

- rehashidx用于表示是否在进行rehash，-1表示不在进行。

**rehash介绍**

创建一个比ht[0]更大的ht[1]，size为大于`used * 2`的2 的指数，开始值为4；

将 ht[0]->table 中的所有键值对迁移到 ht[1]->table ；

将原有 ht[0] 的数据清空，并将 ht[1] 替换为新的 ht[0] ；

进行rehash的**条件**：

自然 rehash ： ratio >= 1 ，且变量 dict_can_resize 为真。

强制 rehash ： ratio 大于变量 dict_force_resize_ratio （目前版本中， dict_force_resize_ratio 的值为 5 ）。

### 加进了解

![graphviz-10472d0cd7aa2ee803003650472c9bac72f5bf39](E:\实习\Java_docs\pics\graphviz-10472d0cd7aa2ee803003650472c9bac72f5bf39.png)



### 跳跃表

跳跃表是有序集合的底层实现之一，支持平均O(logn)的节点查找复杂度。

![image-20210923221428270](E:\实习\Java_docs\pics\image-20210923221428270.png)

位于左边的zskiplist结构，该结构包含以下属性：

- header：指向跳跃表的表头节点
- tail：指向跳跃表的表尾节点
- level：记录目前跳跃表内，层数最大的那个节点的层数
- length：记录跳跃表的长度，跳跃表目前包含节点的数量。

位于zskiplist结构右方的是四个zskiplistNode结构：

- 层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点。而跨度则记录了前进指针所指向节点和当前节点的距离。
- 后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。
- 分值： 各个节点中的1.0、2.0是节点所保存的分支。在跳跃表中，节点按各自所保存的分值从小到大排列。
- 成员对象：各个节点中的o1、o2是节点所保存的成员对象。

跳跃表节点的实现：

```c
* 跳跃表节点
 */
typedef struct zskiplistNode {
    // 成员对象
    robj *obj;
    // 分值
    double score;
    // 后退指针
    struct zskiplistNode *backward;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[]; 
} zskiplistNode;
```

其中，成员对象不能重复，分值可以重复，重复时按成员对象顺序排。

### 整数集合

当集合对象的所有元素都是**整数值**，并且保存的元素数量小于512个时，使用整数集合作为底层。

```c
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
```

尽管contents的类型为int8_t，但是实际是根据编码方式改变。并且它以有序和无重复的方式保存数据。

**升级：**

整数集合中原来保存的是小类型（如：int16_t）的整数，当插入比其类型大（如：int_64_t）的整数时，会把整合集合里的元素的数据类型都转换成大的类型，这个过程称为升级

升级整数集合并添加新元素步骤如下：

（1）根据新元素的类型，扩展整数集合的底层数据的空间大小，并为新元素分配空间。

（2）将现有的所有元素的类型转换成与新元素相同的类型，保持原有数据有序性不变的情况下，把转换后的元素放在正确的位置上。

（3）将新元素添加到数组里。

新元素引发升级，所以新元素要么比所有元素都大，要么比所有元素都小。

当小于所有元素时，新元素放在底层数组的最开头

当大于所有元素时，新元素放在底层数据的最末尾

### 压缩列表

[Redis数据结构——压缩列表 - Mr于 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hunternet/p/11306690.html)

- 压缩列表是一种为节约内存而开发的顺序型数据结构
- 被用作列表键和哈希键的底层实现之一。
- 可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
- 添加新节点到压缩列表，或者从压缩列表中删除节点，可以回引发连锁更新操作，但是几率不高。

![image-20210923234044935](E:\实习\Java_docs\pics\image-20210923234044935.png)

```c
struct ziplist {
	uint32_t zlbytes; /* 4 个字节，表示整个 ziplist 占用的字节数 */
	uint32_t zltail; /* 4 个字节，存储到链表最后一个节点的偏移值 */
	uint16_t zllen; /* 2 个字节，存储到链表中节点的个数 */
	uint8_t zlend; /* 1 个字节，硬编码 0xFF 标识链表的结束 */
} ziplist;
```

**zlbytes**: 记录整个压缩列表占用的内存字节数；在对压缩列表进行内存重分配，或者计算zlend的位置时使用。

**zltail**: 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾字节的地址。

**zllen**：记录压缩列表包含的节点数量，当这个属性的值小于（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值大于（65535）时，需要遍历整个压缩列表才能计算。

**entry**: 列表节点， 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。

**zlend**：特殊值0xFF(十进制255)，用于标记压缩列表的末端。

压缩列表节点的构成：

![image-20210924193955291](E:\实习\Java_docs\pics\image-20210924193955291.png)

![image-20210924194027882](E:\实习\Java_docs\pics\image-20210924194027882.png)

**连锁更新：**

新增或删除节点时，可能触发连锁更新。以删除为例，删除节点的前置节点称为cur，后置节点称为next。cur节点长度超过254，next的“前置节点长度”空间不足以存储254时，需要对next的“前置节点长度”进行扩容，如果next节点扩容后的长度刚好超过254，就会导致next的后置节点也需要对其“前置节点长度”空间扩容，导致连环更新“前置节点长度”空间

![image-20210924210649788](E:\实习\Java_docs\pics\image-20210924210649788.png)

## 五大数据类型

### RedisObject

```c
    typedef struct redisObject {
        //类型
        unsigned type:4;
        //编码
        unsigned encoding:4;
        unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
        int refcount;
        void *ptr;
    } robj;
```

redis是以键值对存储数据的，所以对象又分为键对象和值对象，即存储一个key-value键值对会创建两个对象，键对象和值对象。

**键对象总是一个字符串对象**，而值对象可以是**五大对象**中的任意一种。

type属性存储的是对象的类型，也就是我们说的 string、list、hash、set、zset中的一种，可以使用命令 TYPE key 来查看。

### 字符串

#### String类型的内部编码情况

字符串对象底层数据结构实现为简单动态字符串（SDS）和直接存储，但其编码方式可以是int、raw或者embstr，区别在于内存结构的不同。

- **int 编码**：保存long 型的64位有符号整数
- **embstr 编码**：保存长度小于44字节的字符串
- **raw 编码**：保存长度大于44字节的字符串

![image-20210924230451502](E:\实习\Java_docs\pics\image-20210924230451502.png)

- *len*： 字符串的长度（实际使用的长度）
- *alloc*：分配内存的大小
- *flags*: 标志位，低三位表示类型，其余五位未使用
- *buf*： 字符数组

#### INT 编码格式

命令示例： `set foo 123`

当字符串键值的内容可以用一个**64位有符号整型**来表示时，Redis会将键值转化为 long型来进行存储，此时即对应 `OBJ_ENCODING_INT` 编码类型。

内存结构：

![image-20210924232210029](E:\实习\Java_docs\pics\image-20210924232210029.png)

而且 Redis 启动时会预先建立 **10000** 个分别存储 **0~9999** 的 redisObject 变量作为共享对象，这就意味着如果 set字符串的键值在 0~10000 之间的话，则可以 **直接指向共享对象** 而不需要再建立新对象，此时键值不占空间！

因此，当执行如下指令时：

```
set key1 100
set key2 100
```

![image-20210924232609094](E:\实习\Java_docs\pics\image-20210924232609094.png)

#### EMBSTR编码格式

命令示例： `set foo abc`

Redis 在保存长度小于 **44** 字节的字符串时会采用 `OBJ_ENCODING_EMBSTR` 编码方式

![image-20210924235349049](E:\实习\Java_docs\pics\image-20210924235349049.png)

从内存结构上来讲 即字符串 sds结构体与其对应的 redisObject 对象分配在 **同一块连续的内存空间**，这就仿佛字符串 sds 嵌入在 redisObject 对象之中一样.

![image-20210924235817045](E:\实习\Java_docs\pics\image-20210924235817045.png)

#### RAW编码格式

指令示例： `set foo abcdefghijklmnopqrstuvwxyzabcdeffasdffsdaadsx`

当字符串的键值为长度大于 **44** 的 **超长字符串** 时，Redis 则会将键值的内部编码方式改为 `OBJ_ENCODING_RAW` 格式；此时动态字符串 sds 的内存与其依赖的 redisObject 的 **内存不再连续** 了。

![image-20210925113234310](E:\实习\Java_docs\pics\image-20210925113234310.png)

### 列表

列表对象的编码可以是ziplist和linkedlist之一。

#### ziplist编码

当所有字符串元素的长度都小于64字节，字符串元素小于512个时使用ziplist编码，每个压缩列表节点保存了一个列表元素。

![image-20210925113950032](E:\实习\Java_docs\pics\image-20210925113950032.png)

#### linkedlist编码

linkedlist编码底层采用双端链表实现，每个双端链表节点都保存了一个字符串对象，在每个字符串对象内保存了一个列表元素。

![image-20210925114040001](E:\实习\Java_docs\pics\image-20210925114040001.png)

#### 相互转换

列表对象使用ziplist编码需要满足两个条件：一是所有字符串长度**都小于**64字节，二是元素数量**小于**512，不满足任意一个都会使用linkedlist编码。

### 哈希表

哈希对象的编码可以是ziplist和hashtable之一。

在 **数据条目较少**，**数据值较小** 的时候 Redis会采用 **压缩列表**（OBJ_ENCODING_ZIPLIST）编码方式进行存储。这里成员”较少”，成员值”较小”的标准可以通过如下配置项进行配置：

```
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
```

当 **字段值长度大于64**时，编码格式会由 ZIPLIST方式切换为 Hashtable方式:

![image-20210925115639455](E:\实习\Java_docs\pics\image-20210925115639455.png)

![image-20210925115849434](E:\实习\Java_docs\pics\image-20210925115849434.png)

#### ziplist编码

#### HashTable编码

在 Redis内部，从 OBJ_ENCODING_HT类型到底层真正的散列表数据结构是一层层嵌套下去的，关系如下：

![image-20210925120000465](E:\实习\Java_docs\pics\image-20210925120000465.png)

##### 哈希节点

```c
typedef struct dictEntry{
    void *key;
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    }v;
    //Redis 哈希表使用链地址法解决键冲突，此next指针用于连接被分配到同一个索引上的多个节点
    struct dictEntry *next;
}dictEntry;
```

##### 哈希表

```c
typedef struct dictht{
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
}dictht;
```

##### 字典

```c
typedef struct dict{
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx;
    unsigned long iterators;
}
```

##### 如何计算Hash值

`idx = hash & d -> ht[table].sizemask;`

#### 渐进式Hash

数据的迁移并不是一步完成的，所以需要有一个索引来指示当前的`rehash`进度。当`rehashidx`为`-1`时，代表没有哈希操作。

- 判断`dict`是否正在`rehashing`,才能继续往下进行，否则已经结束哈希过程，直接返回。
- 接着是分`n`步进行的渐进式哈希主体部分（`n`由函数参数传入），在`while`的条件里面加入对`.used`旧表中剩余元素数目的观察，增加安全性。
- 一个`runtime`的断言保证一下渐进式哈希的索引没有越界。

- 接下来一个小`while`是为了跳过空桶，同时更新剩余可以访问的空桶数
- 现在我们来到了当前的`bucket`，在下一个`while(de)`中把其中的所有元素都迁移到`ht[1]`中，索引值是辅助了哈希表的大小掩码计算出来的，可以保证不会越界。同时更新了两张表的当前元素数目。

- 每一步`rehash`结束，都要增加索引值，并且把旧表中已经迁移完毕的`bucket`置为空指针。
- 最后判断一下旧表是否全部迁移完毕，若是，则回收空间，重置旧表，重置渐进式哈希的索引，否则用返回值告诉调用方，`dict`内仍然有数据未迁移。

### 集合

集合对象的编码可以是intset和hashtable之一。

集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。

集合类型和列表类型的区别如下：

- 列表可以存储重复元素，集合只能存储非重复元素；
- 列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。

一个集合最多可以存储23^2-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。

#### intset编码

intset编码的集合对象底层实现是整数集合，所有元素都保存在整数集合中。

![image-20210926194358438](E:\实习\Java_docs\pics\image-20210926194358438.png)

### 有序集合

有序集合的编码可以是ziplist和skiplist之一。

## 内存回收

Redis采用引用计数进行内存回收，每个对象的引用计数信息由redisObject的refcount记录，可使用objecct refcount查询。

对象的引用计数信息会随着对象的使用状态而变化：

- 在创建一个新对象时，引用计数的值会被初始化为1；
- 当对象被一个新程序使用时，它的引用计数值会被增1；
- 当对象不再被一个程序使用时，它的引用计数值会被减1；
- 当对象的引用计数值变为0时，对象所占用的内存会被释放。

## 对象共享

比如一个键A的值是100，

![image-20210926201656949](E:\实习\Java_docs\pics\image-20210926201656949.png)

![image-20210926201706108](E:\实习\Java_docs\pics\image-20210926201706108.png)

![image-20210926201713799](E:\实习\Java_docs\pics\image-20210926201713799.png)

## 对象的空转时间

![image-20210926201824990](E:\实习\Java_docs\pics\image-20210926201824990.png)

此外，对象的空转时间还用于回收内存，在服务器占用的内存超过最大值时，空转时间较长的会被服务器优先释放。

## 设置键的过期时间

通过EXPIRE或PEXPIRE设置秒或毫秒过期时间。

通过EXPIREAT或PEXPIREAT设置具体过期时间，时间戳表示秒或毫秒。

TTL或PTTL返回剩余生存时间，秒或毫秒

PERSIST移除过期时间

![image-20210926202743473](E:\实习\Java_docs\pics\image-20210926202743473.png)

数据库结构中的expires保存着每个键的过期时间。

expires 同样是字典结构，但其存储的是key-value过期时间；当我们设置了key-value的过期时间，那么key-value存储在dict字典中，而过期时间则存储在expires中；字典的键存储key，字典的值存储过期时间；这里需要注意的是，无论设置的过期时间是秒还是毫秒，最终存储时都会转换为unix毫秒时间戳。

![image-20210926203318054](E:\实习\Java_docs\pics\image-20210926203318054.png)

## Redis的删除策略

![image-20210926203428816](E:\实习\Java_docs\pics\image-20210926203428816.png)

## 过期键在RDB中和AOF中的处理

![image-20210926203544638](E:\实习\Java_docs\pics\image-20210926203544638.png)

### 载入时

![image-20210926203700049](E:\实习\Java_docs\pics\image-20210926203700049.png)

![image-20210926203755358](E:\实习\Java_docs\pics\image-20210926203755358.png)

![image-20210926204054450](E:\实习\Java_docs\pics\image-20210926204054450.png)

## 主从模式删除

![image-20210926204612282](E:\实习\Java_docs\pics\image-20210926204612282.png)

## 什么是持久化

上面说道的无论是数据库还是期内的数据都是存储在服务器内内存中的，如果服务器一旦发生掉电，进程退出等情况，那么其内存中的数据就都消失不见了，在我们大规模并发的项目下，显然这是灾难性的，所以应对这种情况的办法之一，就是**持久化，把内存中的数放到磁盘中**，意外发生后，能够从磁盘上进行数据恢复到内存中，这样就避免了数据丢失。

Redis提供了两种持久化方式RDB持久化和AOF持久化。

### RDB持久化

通过保存键值对来保存数据库状态

#### RDB文件的生成：

一是使用**SAVE**，二是使用**BGSAVE**,区别在于SAVE会阻塞服务器进程，直到RDB文件生成结束后，但是BGSAVE会创建子进程负责创建rdb文件，主进程继续执行其它命令

![image-20210926205120214](E:\实习\Java_docs\pics\image-20210926205120214.png)

#### RDB文件载入：

由系统自动判断，启动时判断是否有rdb文件，有就直接载入，不过有以下注意，RDB载入时系统处于阻塞状态，直到载入完毕

![image-20210926205220223](E:\实习\Java_docs\pics\image-20210926205220223.png)

自动间隔性保存

因为BGSAVE命令是异步执行，不会阻塞服务器，所以Redis允许用户自行配置SAVE选项，当选项触发时自动执行BGSAVE命令。 

当用户开启了触发自动BGSAVE后，如果不配置save选项，服务器会使用默认设置，如下：

![image-20210926205237186](E:\实习\Java_docs\pics\image-20210926205237186.png)

![image-20210926205309471](E:\实习\Java_docs\pics\image-20210926205309471.png)

#### RDB文件的结构

![image-20210926205440573](E:\实习\Java_docs\pics\image-20210926205440573.png)

其中REDIS是固定的5字节，保存着REDIS5个字符，用于判断文件是不是RDB文件。Db_version长度4字节，保存数据库版本号。Databases保存零个或多个数据库，以及数据库中的键值对。EOF长度一字节，表示终止符。Check_sum8字节长无符号，表示一个校验和。

#### Databases具体结构

### AOF持久化

AOF持久化是通过保存修改数据库的写命令来记录数据库状态

![image-20210926205904917](E:\实习\Java_docs\pics\image-20210926205904917.png)

AOF持久化操作分为命令追加、文件写入、文件同步三步。

- 命令追加，AOF持久化是先把命名放在服务器中的AOF缓存区的，每执行一个写命令，就会追加一条写命令到Aof缓冲区末尾。

<img src="E:\实习\Java_docs\pics\image-20210926210019875.png" alt="image-20210926210019875" style="zoom:50%;" />

![image-20210926210125083](E:\实习\Java_docs\pics\image-20210926210125083.png)

所以还分为文件写入和同步

![image-20210926210301524](E:\实习\Java_docs\pics\image-20210926210301524.png)

![image-20210926210323702](E:\实习\Java_docs\pics\image-20210926210323702.png)

默认值为everysec

AOF的载入流程：

（1）Redis会创建一个伪客户端，伪客户端与真实的客户端执行命令的效果是一样的，只是不带网络连接。

（2）从AOF文件分析并读取一条命令。

（3）伪客户端执行这条命令。

（4）重复2和3过程，知道AOF文件中的所有命令处理完成。

### AOF文件重写

AOF文件的持久化是记录被执行对的命令，这样随着时间越来越长，AOF文件中的内容会越来越多，体积也会越来越大，文件越大恢复数据的时间也越多。

在命令执行的过程中有些键值对被删除了，有些被修改了，而这些过程命令是完全没有必要再执行一遍的，所以Redis提供了AOF文件的重写功能对AOF进行重建，使用重建后的文件要比元AOF文件体积小很多。

**AOF文件重写，并不需要对原AOF文件进行任何访问改动，他是通过对数据库内的数据读取来操作的，即查看数据库内有什么数据，然后根据数据类型进行创建这些数据的写入命令。**

**AOF文件重写是由子进程进行的，并不影响主进程处理命令；**子进程而不是线程，因为进程带有数据副本，不锁数据的情况下，能保证安全。

AOF文件子进程重写过程中，主进程仍然在处理数据，这样造成了子进程和主进程的数据不一致，子进程数据少了一部分，这种情况下Redis会创建一个AOF重写缓冲区；这样少的那部分命令会写到AOF重写缓冲区中，重写完成后，再把缓冲区这些命令写进新的AOF文件中，然后用新的AOF文件替换就得AOF文件。

也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：

- 执行客户端发来的命令
- 将执行后的写命令追加到AOF缓冲区
- 将执行后的写命令追加到AOF重写缓冲区

### 触发AOF后台重写的条件

1. AOF重写可以由用户通过调用**BGREWRITEAOF**手动触发。
2. 服务器在AOF功能开启的情况下，会维持以下三个变量：

- 记录当前AOF文件大小的变量aof_current_size

- 记录最后一次AOF重写之后，AOF文件大小的变量aof_rewrite_base_size

- 增长百分比变量aof_rewrite_perc

每次当serverCron（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：

 

没有BGSAVE命令（RDB持久化）/AOF持久化在执行；

没有BGREWRITEAOF在进行；

当前AOF文件大小要大于server.aof_rewrite_min_size（默认为1MB），或者在redis.conf配置了auto-aof-rewrite-min-size大小；

当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比（在配置文件设置了auto-aof-rewrite-percentage参数，不设置默认为100%）

如果前面三个条件都满足，并且当前AOF文件大小比最后一次AOF重写时的大小要大于指定的百分比，那么触发自动AOF重写。

## 旧版数据库复制

在旧版数据库复制中，复制分为**同步**和**命令传播**，其中同步就是在发送slaveof命令后，将从服务器的数据库状态转为主服务器。

从服务器对主服务器的同步操作需要通过主服务器发送`SYNC`命令来完成，以下是SYNC命令的执行步骤：

1. 从服务器向主服务器发送SYNC命令。
2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
3. 当主服务器的BGSAVE命令执行完毕后，主服务器会将BGSAVE命令生成的RDB发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。

![image-20210927173018445](E:\实习\Java_docs\pics\image-20210927173018445.png)

命令传播是指当完成同步后，主从服务器处于一个数据库状态，但是一个服务器执行了写命令后就会导致变化，这时候需要把该服务器执行的命令发送给另一个服务器

## 旧版复制功能的缺陷

在Redis中，从服务器对主服务器的复制可以分为以下两种情况：

- 初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
- 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，效率很低。

这是由于在断线后重复制，旧版复制功能还是使用同步进行一次完整的复制，**其实只要执行断线后，另一个服务器执行的那些命令就好了。**

## 新版复制功能实现

**主要是加入了部分重同步**

使用PSYNC命令代替SYNC命令来执行复制时的同步操作。

PSYNC命令具有完整重同步( full resynchronization）和部分重同步( partial resynchronization)两种模式:

其中完整重同步用于处理初次复制情况:完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。

**而部分重同步则用于处理断线后重复制情况:当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。**

怎么判断是执行**部分重同步**：

### 复制偏移量

通过对比主从服务器地复制偏移量，程序可以知道主从服务器是否处于一致状态：

- 如果主从服务器处于一致状态，那么主从服务器两者地偏移量总是相同。

![image-20210927174920913](E:\实习\Java_docs\pics\image-20210927174920913.png)

### 复制积压缓冲区

当主服务器进行命令传播时，不仅会把命令传给从服务器，也会把它存到复制积压缓冲区。这里记录了每个命令导致的复制偏移量。

执行哪种同步操作：

当从服务器重新连上主服务器时，从服务器通过PSYNC命令将自己的复制偏移量offset发给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：

- 如果offset偏移量之后的数据（也就是偏移量offset + 1开始的数据）仍然存在于复制积压区里面，那么主服务器将对从服务器执行部分重同步操作。
- 相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。

### 服务器ID

当从服务器对主服务器进行**初次复制**时，主服务器会将自己的**运行ID**传送给从服务器，而从服务器则会将这个运行ID保存起来。

当从服务器**断线并重新连上**一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID:

- 如果从服务器保存的运行ID和当前连接的主服务器的运行ID**相同**，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
- 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID**并不相同**,那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

Psync流程图：

<img src="E:\实习\Java_docs\pics\image-20210927190129668.png" alt="image-20210927190129668" style="zoom:80%;" />

## 哨兵

**高可用性：**指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行，减少停工时间。

高可用性通常通过提高系统的容错能力来实现。定义一个系统怎样才算具有高可用性往往需要根据每一个案例的具体情况来具体分析。

有以下方法解决高可用性：

（1）**主从方式** （非对称方式）

工作原理：主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。

（2）双机双工方式（互备互援）

工作原理：两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。

（3）集群工作方式（多服务器互备方式）

工作原理：多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。

**主从切换技术的方法是**：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。Sentinel可以监视任意多个主服务器

以及主服务器属下的从服务器，并在被监视的主服务器下线时，自动执行故障转移操作。

### 哨兵的作用

- 监控
- - 不断地检查master和slave是否正常运行
  - master存活检测、master与slave运行情况检测
- 通知（提醒）
- - 当被监控地服务器出现问题时，向其他（哨兵间，客户端）发送通知。
- 自动故障转移
- - 断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新地服务器地址

### 启用哨兵模式



