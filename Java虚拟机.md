# Java虚拟机

## JVM体系结构&JVM内存区域

![image-20220112164218953](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112164218953.png)

JVM内存区域包括PC计数器、Java虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存。

程序计数器、虚拟机栈、本地方法栈属于每个**线程私有的**；堆和方法区属于**线程共享访问的**。

1. **运行时数据区**：经过编译生成的字节码文件（class文件），由class loader（类加载子系统）加载后交给执行引擎执行。在执行引擎执行的过程中产生的数据会存储在一块内存区域。

2. **程序计数器**：用于记录当前线程的正在执行的字节码指令位置。由于虚拟机的多线程是切换线程并分配CPU执行时间的方式实现的，不同线程的执行位置都需要记录下来，因此程序计数器是**线程私有**的。

3. **虚拟机栈**：虚拟机栈是 Java 方法执行的内存结构，虚拟机会在每个 Java 方法执行时创建一个“栈桢”，用于存储局部变量表，操作数栈，动态链接，**方法出口**等信息。当方法执行完毕时，该栈桢会从虚拟机栈中出栈。其中局部变量表包含基本数据类型和对象引用。

   - **局部变量表**是一组**变量值**的存储空间，用于存储**方法参数**和**局部变量**。 在 `Class` 文件的方法表的 `Code` 属性的 `max_locals` 指定了该方法所需局部变量表的**最大容量**。

     在编译期间分配内存空间，可以存放编译期的各种变量类型：

     1. **基本数据类型** ：`boolean`, `byte`, `char`, `short`, `int`, `float`, `long`, `double`等`8`种；
     2. **对象引用类型** ：`reference`，指向对象**起始地址**的**引用指针**；
     3. **返回地址类型** ：`returnAddress`，返回地址的类型。

   - **操作数栈**：（Operand Stack)也称为操作栈，是一个后入先出栈。在`Class`文件的`Code`属性中的max_stacks指定了执行过程中最大的栈深度。

     1. 和**局部变量表**一样，**操作数栈**也是一个以`32`**字长**为单位的数组。
     2. 虚拟机在操作数栈中可存储的**数据类型**：`int`、`long`、`float`、`double`、`reference`和`returnType`等类型 (对于`byte`、`short`以及`char`类型的值在压入到操作数栈之前，也会被转换为`int`)。
     3. 和**局部变量表**不同的是，它不是通过**索引**来访问，而是通过标准的**栈操作** — **压栈**和**出栈**来访问。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。

   - **动态链接** ：每个**栈帧**都包含一个指向运行时**常量池**中所属的**方法引用**，持有这个引用是为了支持方法调用过程中的动态链接。

     `Class`文件的**常量池**中存在有大量的**符号引用**，字节码中的**方法调用指令**就以常量池中指向方法的**符号引用**为参数。这些符号引用：

     1. 静态解析：一部分会在**类加载阶段**或第一次使用的时候转化为**直接引用**（如`final`、`static`域等），称为**静态解析**，
     2. 动态解析：另一部分将在每一次的**运行期间**转化为**直接引用**，称为**动态链接**。

4. **本地方法栈**：类似 Java 方法的执行有虚拟机栈，本地方法的执行则对应有本地方法栈

5. **方法区**：用于存储已被虚拟机加载的类信息，**常量，静态变量，即时编译器编译后的代码**等数据。**线程共享**

6. **Java堆**（Heap）：Java堆是被所有**线程共享**的**最大**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。

   在Java中，堆被划分为两个不同的区域：**新生代（Young Generation）**、**老年代（Old Generation）**。新生代又被划分为3个区域： 一个Eden区和两个Survivor区 

   新的对象分配是首先放在年轻代 (`Young Generation`) 的`Eden`区，`Survivor`区作为`Eden`区和`Old`区的缓冲，在`Survivor`区的对象经历若干次收集仍然存活的，就会被转移到老年代`Old`中。

## JVM是如何工作的

1. 类加载器子系统
2. 运行时数据区
3. 执行引擎

**类加载器子系统**

Java的动态类加载功能是由类加载器子系统处理的。它负责加载、链接，并且在**运行时**首次引用类的时候初始化类，而不是在编译期间。

**加载**

负责加载类。BootStrap类加载器、Extension类加载器和Application类加载器是实现这个功能的三大类加载器。

1. **BootStrap类加载器** —— 负责从classpath加载类，如果没有类存在，将只加载**rt.jar**。这个加载器的优先级最高。
2. **Extension类加载器** —— 负责加载**扩展文件夹（jre\lib）**中的类。
3. **Application类加载器** —— 负责加载**应用级classpath**和环境变量指向的路径下的类。

**链接**

1. **校验** —— 字节码验证器将校验生成的字节码是否正确，如果校验失败，将获得**校验错误信息**。
2. **准备** —— 对于所有的静态变量，内存将被申请并分配默认值。
3. **解析** —— 所有**标记的内存引用**从**方法区域**被替换成的**原始引用**。

**初始化**

所有的静态变量都将被分配原值i，静态代码块将被执行。

**执行引擎**

分配到运行时数据区的字节码将被执行引擎执行。执行引擎读取字节码并逐一执行。

## 判断一个对象是否可被回收

**程序计数器、虚拟机栈和本地方法栈**这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 **Java 堆和方法区**进行。

### 引用计数算法

**描述**：给对象中添加一个引用计数器每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。

**缺陷**：很难解决对象间相互循环引用的问题

### 可达性分析算法

通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112180515272.png" alt="image-20220112180515272" style="zoom:80%;" />

**★ GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象？**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象。

### 引用类型

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

#### 强引用

被强引用关联的对象不会被回收。

使用`new`一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用SoftReference类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
```

#### 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

```java
Object obj = new Object();
WeakReference<Object> sf = new WeakReference<>(obj);
obj = null;
```

#### 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。

为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 垃圾收集算法

### 标记-清除

![image-20220112185621054](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112185621054.png)

**不足：**

- **效率问题**：标记和清除的效率都不高
- **空间问题**：标记清除之后会产生大量不连续的内存碎片，导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集。

### 复制

![image-20220112185842493](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112185842493.png)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都**采用这种收集算法来回收新生代**，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

### 标记-整理

解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。

## 垃圾收集器

一般将堆分为新生代和老年代。

- 新生代使用：**复制回收** 算法
- 老年代使用：**标记 - 清除** 或者 **标记 - 整理** 算法

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112190658330.png" alt="image-20220112190658330" style="zoom:80%;" />

- 单线程与多线程：单线程指的是垃圾收集器**只使用一个线程**进行收集，而多线程使用多个线程；

- 串行与并行：串行指的是垃圾收集器与用户程序**交替执行**，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 **CMS 和 G1** 之外，其它垃圾收集器都是以串行的方式执行。

### Serial

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112191222433.png" alt="image-20220112191222433" style="zoom:80%;" />

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

### ParNew

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112191446258.png" alt="image-20220112191446258" style="zoom:80%;" />

它是 Serial 收集器的**多线程版本**。

**JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个**。

默认开启的线程数量与 CPU 数量相同，可以使用 `-XX:ParallelGCThreads` 参数来设置线程数。

### Parallel Scavenge

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112191737853.png" alt="image-20220112191737853" style="zoom:80%;" />

Parallel Scavenge 收集器是一个**新生代收集器**，它也是使用复制算法的收集器，又是并行的多线程收集器。

**与 ParNew 的不同之处：**

其它收集器关注点是尽可能**缩短垃圾收集用户线程地停顿时间**，而它的目标是达到一个可控制的吞吐量，它被称为 **吞吐量优先收集器**。

> 吞吐量指 CPU 用于运行用户代码的时间占总时间的比值
>
> 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

Parallel Scavenge 收集器气提供了两个参数用于**精确控制吞吐量**

- **最大垃圾收集停顿时间：** -XX:MaxGCPauseMills
- **吞吐量大小：**-XX:GCTimeRatio

### Serial Old

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112195040897.png" alt="image-20220112195040897" style="zoom:80%;" />

Serial Old 是 Serial 收集器的**老年代版本**，它同样是一个单线程收集器，使用 ”标记-整理“ 算法。

### CMS

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112195552905.png" alt="image-20220112195552905" style="zoom:80%;" />

CMS(Concurrent Mark Sweep), Mark Sweep指的是**标记-清除**算法。

特点：并发收集、低停顿。

四个流程：

- 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿。
- **并发标记**：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- **并发清除**：不需要停顿。

缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。

- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
  - CMS 提供了一个开关参数 **-XX:+UseCMSCompactAtFullCollection**（默认开启），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的。
  - 参数 **-XX:CMSFullGCsBeforeCompaction** 用于设置执行多少次不压缩的 Full GC后，跟着来以此带压缩的

### G1

Garbage-First

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

G1 把堆划分成多个大小相等的**独立区域（Region）**，新生代和老年代不再物理隔离。

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112200503695.png" alt="image-20220112200503695" style="zoom:80%;" />

通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。



每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。



- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。

### 比较

| 收集器                | 单线程/并行 | 串行/并发 | 新生代/老年代   | 收集算法             | 目标         | 适用场景                                      |
| --------------------- | ----------- | --------- | --------------- | -------------------- | ------------ | --------------------------------------------- |
| **Serial**            | 单线程      | 串行      | 新生代          | 复制                 | 响应速度优先 | 单 CPU 环境下的 Client 模式                   |
| **ParNew**            | 并行        | 串行      | 新生代          | 复制算法             | 响应速度优先 | 多 CPU 环境时在 Server 模式下与 CMS 配合      |
| **Parallel Scavenge** | 并行        | 串行      | 新生代          | 复制算法             | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **Serial Old**        | 单线程      | 串行      | 老年代          | 标记-整理            | 响应速度优先 | 单 CPU 环境下的 Client 模式、CMS 的后备预案   |
| **Parallel Old**      | 并行        | 串行      | 老年代          | 标记-整理            | 吞吐量优先   | 在后台运算而不需要太多交互的任务              |
| **CMS**               | 并行        | 并发      | 老年代          | 标记-清除            | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
| **G1**                | 并行        | 并发      | 新生代 + 老年代 | 标记-整理 + 复制算法 | 响应速度优先 | 面向服务端应用，将来替换 CMS                  |



## 内存分配与回收策略

### 什么时候进行Minor GC， Full GC

- Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此Minor GC会频繁执行。
- Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

### 内存分配策略

**对象优先在Eden分配**

大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。

**大对象直接进入老年代**

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

`-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

**长期存活的对象进入老年代**

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。

### Full GC 触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

**调用System.gc()**

只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。

**老年代空间不足**

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

**JDK1.7及以前的永久代空间不足**

永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

**Concurrent Mode Failure**

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## Student s = new Student()；在内存中做了哪些事情

1. 加载Student.class文件进内存
2. 在栈空间为s开辟空间
3. 在堆空间为Student对象开辟空间
4. 对Student对象的成员变量进行默认初始化
5. 对Student对象的成员变量进行显式初始化
6. 通过构造方法对Student对象的成员变量赋值
7. Student对象初始化完毕，把对象地址赋值给s变量。

## GC调优

[从实际案例聊聊Java应用的GC优化 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

## 内存泄漏

在 Java 中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点

- 这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 这些对象是无用的，即程序以后不会再使用这些对象。

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20220112212840337.png" alt="image-20220112212840337" style="zoom:80%;" />

```java
Vector v = new Vector(10);
for (int i = 1; i < 100; i++) {
    Object o = new Object();
    v.add(o);
    o = null;   
}
```



我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。