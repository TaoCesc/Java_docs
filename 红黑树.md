# 红黑树

**Red-black tree**  自平衡二叉查找树

查找、插入和删除  时间复杂度均为`O(logn)`

## 用途和好处

- 红黑树和[AVL树](https://zh.wikipedia.org/wiki/AVL树)一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。

- 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。

## 性质

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色
2. 根是黑色
3. 所有叶子都是黑色（叶子是NIL节点）
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子道根的所有路径上不能有连续的两个红色节点）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

![image-20210911195827976](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210911195827976.png)

**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。**

## 操作

我们首先[以二叉查找树的方法](https://zh.wikipedia.org/wiki/二叉查找树#插入)增加节点并标记它为红色。

**不设置为黑色的原因：**

（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）



# B树

**B树**（英语：B-tree）是一种自平衡的[树](https://zh.wikipedia.org/wiki/树_(数据结构))，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在[对数时间](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)内完成。

与[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。

## 概述

内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。

例如，在一个2-3 B树（通常简称[2-3树](https://zh.wikipedia.org/wiki/2-3树)），每一个内部节点只能有2或3个子节点。

## 数据库的问题

### 已排序文件的查找时间

大数据库一直以来被存储在磁盘。

乐观来说，如此，在一百万中定位一笔记录将会话花费20次磁盘读取乘上10毫秒每次读取时间，总共是0.2秒。

### B树运用的理念

B树使用了以上所有的想法。特别是：

- 保持键值有序，以顺序遍历
- 使用层次化的索引来最小化磁盘读取
- 使用不完全填充的块来加速插入和删除
- 通过优雅的遍历算法来保持索引平衡

另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。

### B树的弊端

- 除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到70字符之内。

## 定义

一个m阶的B树是一个有以下属性的树：

1. 每一个节点最多有m个子节点
2. 每一个非叶子节点最少有⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有k个子节点的非叶子节点拥有k - 1个键
5. 所有的叶子节点都在同一层。

**每一个内部节点的键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键： *a*1 和 *a*2 。左边子树的所有值都必须小于 *a*1 ，中间子树的所有值都必须在 *a*1 和*a*2 之间，右边子树的所有值都必须大于 *a*2 。**

## 算法

### 搜索

从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

### 插入

所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。

1. 如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。
2. 否则的话这一节点已经满了，将它平均地分裂成两个节点：
   1. 从该节点的原有元素和新的元素中选择出中位数
   2. 小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。
   3. 分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，如果没有父节点（这一节点是根节点），就**创建一个新的根节点**（增加了树的高度）。

### 删除

