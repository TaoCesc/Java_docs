## 1. 并发一致性问题

### 1.1 丢失修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

<img src="E:\实习\Java_docs\pics\image-20210929140840815.png" alt="image-20210929140840815" style="zoom:50%;" />

### 1.2 脏读

针对未提交数据）如果一个事务中对数据进行了更新，但**事务还没有提交**，另一个事务可以 “看到” 该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所 “看到” 的数据就是一笔脏数据。 **（脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 ）**

**例子：**

　　Mary 的原工资为 1000, 财务人员将 Mary 的工资改为了 8000 (但未提交事务)

　　Mary 读取自己的工资，发现自己的工资变为了 8000，欢天喜地！

　　而财务发现操作有误，回滚了事务，Mary 的工资又变为了1000

　　像这样，Mary记取的工资数8000是一个脏数据。

**解决办法**：

　　把数据库的事务隔离级别调整到 *READ_COMMITTED*

<img src="E:\实习\Java_docs\pics\image-20210929140959885.png" alt="image-20210929140959885" style="zoom:50%;" />

### 1.3 不可重复读

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。**（同时操作，事务1分别读取事务2操作时和提交后的数据，读取的记录内容不一致。不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 ）**

**例子：**

（1）在事务1中，Mary 读取了自己的工资为1000，操作并没有完成

```sql
con1 = getConnection();  
select salary from employee empId ="Mary"; 
```

（2）在事务2中，这时财务人员修改了 Mary 的工资为 2000，并提交了事务.

```sql
con2 = getConnection();  
update employee set salary = 2000;  
con2.commit();  
```

（3）在事务1中，Mary 再次读取自己的工资时，工资变为了2000

```sql
//con1  
select salary from employee empId ="Mary";  
```

在一个事务中前后两次读取的结果并不致，导致了不可重复读。

**解决办法**：

　　如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。把数据库的事务隔离级别调整到REPEATABLE_READ

**图解：**

　　T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<img src="E:\实习\Java_docs\pics\image-20210929141252727.png" alt="image-20210929141252727" style="zoom:67%;" />

### 1.4 幻读

事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 **（和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）**

幻读的重点在于**新增或者删除** (数据条数变化)

同样的条件，第1次和第2次读出来的记录数不一样

**例子：**

目前工资为1000的员工有10人。 （1）事务1，读取所有工资为 1000 的员工（共读取 10 条记录 ）

```sql
con1 = getConnection();  
Select * from employee where salary =1000;  
```

（2）这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000

```sql
con2 = getConnection();  
Insert into employee(empId,salary) values("Lili",1000);  
con2.commit();  
```

事务1再次读取所有工资为 1000的 员工（共读取到了 11 条记录，这就像产生了幻读）

```sql
//con1  
select * from employee where salary =1000;  
```

**解决办法：**

　　如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题。把数据库的事务隔离级别调整到 SERIALIZABLE_READ

**图解：**

　　T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

<img src="E:\实习\Java_docs\pics\image-20210929143920562.png" alt="image-20210929143920562" style="zoom:67%;" />

## 2. 事务隔离级别

### 2.1 读未提交（Read Uncommitted）

最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读。

MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。

任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。

设置全局隔离级别为读未提交。

```text
set global transaction isolation level read uncommitted;
```

读未提交，其实就是可以**读到其他事务未提交的数据**，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间**发生回滚**，那就会出现脏数据问题，读未提交没办法解决脏数据问题。

### 2.2 读已提交（Read Committed)

读已提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 *commit* 命令之后的数据。

读提交事务隔离级别是大多数流行数据库的默认事务隔离界别，比如 **Oracle**，但是不是 MySQL 的默认隔离界别。

每个 select 语句都有自己的一份快照，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的。

![image-20210929145623655](E:\实习\Java_docs\pics\image-20210929145623655.png)

### 2.3 可重复读

可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务**开始时读到的已有数据是什么**，在**事务提交前的任意时刻**，这些数据的值都是一样的。

<img src="E:\实习\Java_docs\pics\image-20210929145835748.png" alt="image-20210929145835748" style="zoom:67%;" />

可重复读做到了，这只是针对已有行的更改操作有效，但是对于新插入的行记录，就没这么幸运了，幻读就这么产生了。

![image-20210929150357328](E:\实习\Java_docs\pics\image-20210929150357328.png)

**要说明的是，当你在 MySQL 中测试幻读的时候，并不会出现上图的结果，幻读并没有发生，MySQL 的可重复读隔离级别其实解决了幻读问题**

### 2.4 **串行化**

串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。

### 2.5 MySQL是如何实现事务隔离的

#### 2.5.1 实现可重复读

MySQL采用了MVVC  **Multi-Version Concurrency Control**（多版本并发控制）的方式。

在数据库表中看到的一行记录可能**实际上有多个版本**，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，而这个字段就是使其产生的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。

![image-20210929155111976](E:\实习\Java_docs\pics\image-20210929155111976.png)

按照上面这张图理解，一行记录现在有 3 个版本，每一个版本都记录这使其产生的事务 ID，比如事务A的transaction id 是100，那么版本1的row trx_id 就是 100，同理版本2和版本3。

**快照，学名叫做一致性视图**，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读已提交则是每次执行语句的时候都重新生成一次快照。

对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：

1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；

#### 2.5.2 并发写问题

两个事务，对同一条数据做修改。

![image-20210929155635470](E:\实习\Java_docs\pics\image-20210929155635470.png)

假设事务A执行 update 操作， update 的时候要对所修改的行**加行锁**，这个行锁会在**提交**之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行，如果事务A的时间太长，那么事务B很有可能出现超时异常。

*加锁的过程要分有索引和无索引两种情况，比如下面这条语句*

```mysql
update user set age=11 where id = 1
```

id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。

而下面这条语句

```mysql
update user set age=11 where age=10
```

**MySQL 会为这张表中所有行加行锁**

但是呢，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。

虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。

#### 2.5.3 解决幻读

解决幻读用的也是锁，叫做间隙锁，MySQL 把**行锁**和**间隙锁**合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。

假设现在表中有两条记录，并且 age 字段已经添加了索引，两条记录 age 的值分别为 10 和 30。

<img src="E:\实习\Java_docs\pics\image-20210929180248662.png" alt="image-20210929180248662" style="zoom:67%;" />

此时，在数据库中会为索引维护一套B+树，用来快速定位行记录。B+索引树是有序的，所以会把这张表的索引分割成几个区间。

![image-20210929180328030](E:\实习\Java_docs\pics\image-20210929180328030.png)

如图所示，分成了3 个区间，(负无穷,10]、(10,30]、(30,正无穷]，在这3个区间是可以加间隙锁的。

![](E:\实习\Java_docs\pics\v2-3ce9ac24fb6fdf3ff60d03e070136175_r.png)

在事务A提交之前，事务B的插入操作**只能等待**，这就是间隙锁起的作用。

当事务A执行`update user set name='风筝2号’ where age = 10;` 的时候，由于条件 where age = 10 ，数据库不仅在 age =10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁，从而导致事务B插入操作无法完成，只能等待事务A提交。

不仅插入 age = 10 的记录需要等待事务A提交，age<10、10<age<30 的记录页无法完成，而大于等于30的记录则不受影响，这足以解决幻读问题了。

***这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否大于等于30，都要等待事务A提交才可以成功插入。***

## 3. 存储引擎

```
MySQL 5.5` 以前的默认存储引擎是 `MyISAM`, `MySQL 5.5` 之后的默认存储引擎是 `InnoDB
```

### 3.1 MyISAM

MySQL 5.5 版本之前的默认存储引擎，在 `5.0` 以前最大表存储空间最大 `4G`，`5.0` 以后最大 `256TB`。

Myisam 存储引擎由 `.myd`（数据）和 `.myi`（索引文件）组成，`.frm`文件存储表结构（所以存储引擎都有）

**特性**

- 并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）
- 表损坏修复
- Myisam 表支持的索引类型（全文索引）
- Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）

**应用场景**

- 没有事务
- 只读类应用（插入不频繁，查询非常频繁）
- 空间类应用（唯一支持空间函数的引擎）
- 做很多 count 的计算

### 3.2 InnoDB

**特性**

- InnoDB为事务性存储引擎
- 完全支持事物的 ACID 特性
- Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）
- InnoDB支持行级锁
- 行级锁可以最大程度的支持并发
- 行级锁是由存储引擎层实现的

**应用场景**

- 可靠性要求比较高，或者要求事务
- 表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。

## 4. 事务

**ACID**

### 4.1 原子性（Atomicity）

不可分割： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

### 4.2 一致性

在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(比如：A向B转账，不可能A扣了钱，B却没有收到)

### 4.3 隔离性

数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。（比如：A正在从一张银行卡里面取钱，在A取钱的过程中，B不能向这张银行卡打钱）

### 4.4 持久性

事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 5 事务的实现

日志文件(redo log 和 undo log)，锁技术以及MVCC

### 5.1 redo log

redo log叫做重做日志，是用来实现事务的**持久性**。

该日志文件由两部分组成：**重做日志缓冲**（redo log buffer）以及**重做日志文件**（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。

![image-20210929185335538](E:\实习\Java_docs\pics\image-20210929185335538.png)

```sql
start transaction;
select balance from bank where name="zhangsan";
// 生成 重做日志 balance=600
update bank set balance = balance - 400; 
// 生成 重做日志 amount=400
update finance set amount = amount + 400;
```

![image-20210929185452918](E:\实习\Java_docs\pics\image-20210929185452918.png)

MySQL 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。

如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致**丢部分已提交事务的修改信息！**

所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。

- 总结：redo log是用来恢复数据的，用于保障，已提交事务的持久化特性（记录了已经提交的操作）

### 5.2 undo log

undo log 叫做回滚日志，用于记录数据被修改前的信息。

undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。

![image-20210929185903924](E:\实习\Java_docs\pics\image-20210929185903924.png)

每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。

- 总结：undo log是用来回滚数据的用于保障，未提交事务的原子性

## 6. 不走索引的情况

```sql
SELECT `sname` FROM `stu` WHERE `age`+10=30;-- 不会使用索引，因为所有索引列参与了计算 

SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) <1990; -- 不会使用索引，因为使用了函数运算，原理与上面相同 

SELECT * FROM `houdunwang` WHERE `uname` LIKE'后盾%' -- 走索引 

SELECT * FROM `houdunwang` WHERE `uname` LIKE "%后盾%" -- 不走索引 

-- 字符串与数字比较不使用索引; 
CREATE TABLE `a` (`a` char(10)); 
EXPLAIN SELECT * FROM `a` WHERE `a`="1" -- 走索引 
EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引，同样也是使用了函数运算 


select * from dept where dname='xxx' or loc='xx' or deptno=45 
-- 如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引，我们建议大家尽量避免使用or 关键字 

-- MySQL内部优化器会对SQL语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引

-- Note：例如 or 、in | not in 、is null | is not null、!=、<>,使用时并不是完全不走索引
```

## 7. 什么时候使用表锁

对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择 InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。

- 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅 这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑 使用表锁来提高该事务的执行速度。 

- 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情 况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

## 8. 联合索引（复合索引）在B+树上的结构

[(9条消息) 联合索引在B+Tree上的存储结构及数据查找方式_木子雷的博客-CSDN博客_联合索引的存储结构](https://blog.csdn.net/feichitianxia/article/details/107997795)

<img src="E:\实习\Java_docs\pics\image-20210929195949887.png" alt="image-20210929195949887" style="zoom:80%;" />

首先，有一个T1表， 然后表T1有字段a,b,c,d,e，其中a是主键，除e为varchar其余为int类型，并创建了一个联合索引`idx_t1_bcd(b,c,d)`，

联合索引的所有索引列都出现在索引数上，并依次比较三列的大小。上图树高只有两层不容易理解，下面是假设的表数据以及我对其联合索引在B+树上的结构图的改进。

![image-20210929200407804](E:\实习\Java_docs\pics\image-20210929200407804.png)

T1表中的数据如下图：

<img src="E:\实习\Java_docs\pics\image-20210929200532724.png" alt="image-20210929200532724" style="zoom:67%;" />

我们先看T1表，他的主键暂且我们将它设为整型自增的 ，InnoDB会使用主键索引在B+树维护索引和数据文件，然后我们创建了一个联合索引（b，c，d）也会生成一个索引树，同样是B+树的结构，只不过它的 **data部分** 存储的是联合索引所在行记录的主键值 **（上图叶子节点紫色背景部分）** 。

联合索引 是个 **非聚簇索引** 。

### 8.1 联合索引具体查找步骤

```sql
select * from T1 where b = 12 and c = 14 and d = 3 ；
```

1. 存储引擎首先从根节点（一般常驻内存）开始查找，第一个索引的第一个索引列为1,12大于1，第二个索引的第一个索引列为56,12小于56，于是从这俩索引的中间读到下一个节点的磁盘文件地址（此处实际上是存在一个指针的，指向的是下一个节点的磁盘位置）。
2. 进行一次磁盘IO，将此节点值加载后内存中，然后根据第一步一样进行判断，发现 数据都是匹配的，然后根据指针将此联合索引值所在的叶子节点也从磁盘中加载后内存，此时又发生了一次磁盘IO，最终根据叶子节点中索引值关联的 **主键值** 。
3. 根据主键值 **回表** 去主键索引树（聚簇索引）中查询具体的行记录。

## 9. 主从复制

### 9.1 主从复制的流程

![image-20210930141023306](E:\实习\Java_docs\pics\image-20210930141023306.png)

1.  在master机器上的操作：

当master上的数据发生变化时，该事件变化会按照顺序写入*bin-log*中。当slave链接到master 的时候，master机器会为slave开启*binlog dump*线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave，并将相应的binlog内容发送给slave。

2. 在slave机器上操作：

当主从同步开启的时候，slave上会创建两个线程： **I\O线程**  该线程连接到master机器， master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog 内容后，再将内容写入到本地的relay log；**sql线程** 该线程读取到I/O线程写入的ralay log。并且 根据relay log。并且根据relay log 的内容对slave数据库做相应的操作。

- update、insert、修改master，查询slave
- master会按照变化顺序写入bin-log
- slave io thread监听master bin-log修改，master会生成dump文件，将bin-log的内容发送给slave，slave会将bin-log复制到自己的中继日志。
- slave io thread 只是获取master的修改，需要sql线程根据中继日志修改数据库。

### 9.2 怎样防止主从复制宕机

## 10. 内连接和外连接

1. inner join只返回两个表中连接字段相等的行

2. left join 左外连接  **左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合 搜索条件的记录。右表记录不足的地方均为NULL。**

3. right join 右外连接
4. 外连接 包括 左外连接和右外连接，但是没有全连接；但是可以通过 union 进行连接

## 11. 索引

### 11.1 索引类型

- 主键索引

Primary Key： 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。

- 唯一索引 

UNIQUE：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以通过ALTER TABLE table_name ADD UNIQUE (column);创建唯一索引：

可以通过ALTER TABLE table_name ADD UNIQUE (column1,column2);**创建唯一组合索引**

- 普通索引 

INDEX：这是最基本的索引，它没有任何限制。可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引

- 组合索引 

INDEX：即一个索引包含多个列，多用于避免回表查询。可以通过ALTER TABLE table_name ADD INDEX index_name(column1,column2, column3);

- 全文索引

 FULLTEXT：也称全文检索，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引

### 11.2 索引设计的原则

1） 适合索引的列是出现在`where`字句中列， 或者连接子句中指定的列；

2） 基数较小的类，索引效果较差，没有必要在此列建立索引；

3） 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；

4） 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。

### 11.3 索引优化

有些时候虽然数据库有索引，但是并不被优化器选择使用。我们可以通过`SHOW STATUS LIKE 'Handler_read%';`查看索引的使用情况：

**Handler_read_key**：如果索引正在工作，Handler_read_key的值将很高。
**Handler_read_rnd_next**：数据文件中读取下一行的请求数，如果正在进行大量的表扫描，值将较高，则说明索引利用不理想。

索引优化规则：

1. *如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。*
   返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。

2. *前导模糊查询不能命中索引。*

```sql
EXPLAIN SELECT * FROM user WHERE name LIKE '%s%';
```

*非前导模糊查询则可以使用索引*

```sql
EXPLAIN SELECT * FROM user WHERE name LIKE 's%';
```

3. *数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。*

```sql
# 不命中索引
EXPLAIN SELECT * FROM user WHERE name=1;
# 命中索引
EXPLAIN SELECT * FROM user WHERE name='1';
```

4. *复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。*

***name,status列创建复合索引：***

```sql
# 命中索引
EXPLAIN SELECT * FROM user WHERE name='xxx' AND status=1;
# or
EXPLAIN SELECT * FROM user WHERE status=1 AND name='xxx';
# 不符合最左匹配原则
EXPLAIN SELECT * FROM user WHERE status = 2;
```

5. *union、in、or都能够命中索引，**建议使用in**。*

6. *用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。*

```sql
EXPLAIN SELECT * FROM payment WHERE name = 'xxx' OR id = 1000;
```

7. *负向条件查询不能使用索引，可以优化为in查询。*
   负向条件有：!=、<>、not in、not exists、not like等。

**status列创建索引**

```sql
# 负向条件不能命中缓存：
EXPLAIN SELECT * FROM user WHERE status !=1 AND status != 2;
# 可以优化为in查询，但是前提是区分度要高，返回数据的比例在30%以内：
EXPLAIN SELECT * FROM user WHERE status IN (0,3,4);
```

8. *范围条件查询可以命中索引。*范围条件有：<、<=、>、>=、between等。

**status, age列分别创建索引**

```sql
# 范围条件查询可以命中索引：
EXPLAIN SELECT * FROM user WHERE status>5;

# 范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引：
EXPLAIN SELECT * FROM user WHERE status>5 AND age<24;

# 如果是范围查询和等值查询同时存在，优先匹配等值查询列的索引：
EXPLAIN SELECT * FROM user WHERE status>5 AND age=24;

# 数据库执行计算不会命中索引
EXPLAIN SELECT * FROM user WHERE age+1>24;
```

**计算逻辑应该尽量放到业务层处理，节省数据库的CPU的同时最大限度的命中索引。**

9. *建立索引的列，不允许为null*

### 11.4 性能调优

- 开启慢查询日志，设置阈值
- explain做慢SQL分析 
- show profile查看SQL在mysql服务器里面的执行细节和生命周期情况 
- SQL数据库服务器的参数调优