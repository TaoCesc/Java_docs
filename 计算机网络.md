## TCP三次握手/四次挥手

### **三次握手**

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：

1. 第一次握手： 客户端给服务器发送一个SYN报文，并表明客户端的初始化序列号ISN，此时客户端处于`SYN_SEND`状态

​	首部的同步位SYN=1，初始序号`seq=x,SYN=1`的报文段不能携带数据，但需要消耗掉一个序号。

2. 第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定了自己的初始化序列号ISN，同时把客户端ISN+1作为ACK的值（即x+1)，表示自己已经收到了客户端的SYN，此时服务器处于`SYN_RCVD`状态

​	在确认报文段中SYN=1，ACK=1，确认号`ack=x+1`,初始序号`seq=y`

3. 第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于`ESTABLISHED`状态。服务器收到ACK报文之后，也处于`ESTABLISHED`状态，此时，双方建立起了连接。

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205133229580.png" alt="image-20211205133229580" style="zoom:67%;" />

#### 为什么需要三次握手，两次不行吗

- 第一次握手： 客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

==因此，需要三次握手才能确认双方的接收与发送能力是否正常。==

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接

#### 什么是半连接队列

服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有完全建立起连接，服务器会把这种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

#### 三次握手过程中可以携带数据吗

**第三次握手的时候，是可以携带数据的。**

### 四次挥手

这是由于TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

刚开始双方都处于ESTABLISHED状态，假如是客户端先发起关闭请求，过程如下：

- 第一次挥手： 客户端发送一个FIN报文，报文会指定一个序列号。此时客户端处于`FIN_WAIT1`状态。即发出**连接释放报文段	**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手： 服务器收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值。表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 
  第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

  ![image-20211205134826545](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205134826545.png)

#### 挥手为什么需要四次

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### 2MSL等待状态

TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

#### 四次挥手释放连接时，等待2MSL的意义?

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。



## HTTPS

HTTPS = HTTP + SSL / TLS

![image-20211205174318153](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205174318153.png)

1. 客户端请求HTTPS网址，然后连接到**服务器的443端口**（HTTPS默认端口，类似于HTTP的80端口）
2. 采用HTTPS协议的服务器有一套数字**CA（Certification Authority）证书**，证书需要申请，并由专门的数字证书认证机构（CA）通过审核后颁发的电子证书。颁发证书的同时会**产生一个私钥和公钥**。私钥由服务端自己保存，不可以泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器相应客户端请求，将证书传递给客户端，证书包含公钥和其他信息。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

> 如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码KEY，并使用公钥A将其加密。

5. 服务器把加密后的随机码KEY发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码KEY之后会使用私钥B将其解密。
7. 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。

> HTTPS 相比 HTTP最大的不同就是多了一层 SSL (Secure Sockets Layer 安全套接层)或 TLS (Transport Layer Security 安全传输层协议)。有了这个安全层，就确保了互联网上通信双方的通信安全

### SSL / TLS 握手详细过程

1. **"client hello"消息：** 客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。

2. **"server hello"消息：** 服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。

3. 验证：

    客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：

   1. 检查数字签名
   2. 验证证书链 (这个概念下面会进行说明)
   3. 检查证书的有效期
   4. 检查证书的撤回状态 (撤回代表证书已失效)

4. **"premaster secret"字符串：** 客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。

5. **使用私钥：** 服务器使用私钥解密"premaster secret"。

6. **生成共享密钥：** 客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 **KEY**。

7. **客户端就绪：** 客户端发送经过共享密钥 **KEY**加密过的"finished"信号。

8. **服务器就绪：** 服务器发送经过共享密钥 **KEY**加密过的"finished"信号。

9. **达成安全通信：** 握手完成，双方使用对称加密进行安全通信。

