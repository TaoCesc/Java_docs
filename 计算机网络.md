## TCP/UDP

### UDP

UDP协议全称是**用户数据报协议**，在网络中它与TCP协议一样用于处理数据包，是一种**无连接**的协议。在OSI模型中，在第四层——**传输层**，处于IP协议的上一层。UDP有**不提供数据包分组**、组装和**不能对数据包进行排序**的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

- **面向无连接**
- **有单播、多播、广播的功能**
- **面向报文**：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
- **不可靠性**

- 头部开销小，传输数据报文时是很高效的

​		**UDP 头部包含了以下几个数据：**

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的















## TCP三次握手/四次挥手

### **三次握手**

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：

1. 第一次握手： 客户端给服务器发送一个SYN报文，并表明客户端的初始化序列号ISN，此时客户端处于`SYN_SEND`状态

​	首部的同步位SYN=1，初始序号`seq=x,SYN=1`的报文段不能携带数据，但需要消耗掉一个序号。

2. 第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定了自己的初始化序列号ISN，同时把客户端ISN+1作为ACK的值（即x+1)，表示自己已经收到了客户端的SYN，此时服务器处于`SYN_RCVD`状态

​	在确认报文段中SYN=1，ACK=1，确认号`ack=x+1`,初始序号`seq=y`

3. 第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于`ESTABLISHED`状态。服务器收到ACK报文之后，也处于`ESTABLISHED`状态，此时，双方建立起了连接。

<img src="https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205133229580.png" alt="image-20211205133229580" style="zoom:67%;" />

#### 为什么需要三次握手，两次不行吗

- 第一次握手： 客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
- 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

==因此，需要三次握手才能确认双方的接收与发送能力是否正常。==

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接

#### 什么是半连接队列

服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有完全建立起连接，服务器会把这种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

#### 三次握手过程中可以携带数据吗

**第三次握手的时候，是可以携带数据的。**

### 四次挥手

这是由于TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

刚开始双方都处于ESTABLISHED状态，假如是客户端先发起关闭请求，过程如下：

- 第一次挥手： 客户端发送一个FIN报文，报文会指定一个序列号。此时客户端处于`FIN_WAIT1`状态。即发出**连接释放报文段	**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手： 服务器收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值。表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 
  第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

  ![image-20211205134826545](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205134826545.png)

#### 挥手为什么需要四次

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### 2MSL等待状态

TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

#### 四次挥手释放连接时，等待2MSL的意义?

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

## HTTP

超文本传输协议（Hyper Text Transfer Protocol）

**特点**：`无连接`、`无状态`、`灵活`、`简单快速`

- **无连接**：每一次请求都要连接一次，请求结束就会断掉，不会保持连接

- **无状态**：每一次请求都是独立的，请求结束不会记录连接的任何信息(**提起裤子就不认人的意思**)，减少了网络开销，这`是优点也是缺点`

- **灵活**：通过http协议中头部的`Content-Type`标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活

- **简单快速**：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

**缺点**：`无状态`、`不安全`、`明文传输`、`队头阻塞`

- **不安全**：`明文传输`可能被窃听不安全，缺少`身份认证`也可能遭遇伪装，还有缺少`报文完整性验证`可能遭到篡改
- **明文传输**：报文(header部分)使用的是明文，直接将信息暴露给了外界，`WIFI陷阱`就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息

- **队头阻塞**：开启`长连接`时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态

### HTTP报文组成部分

**http报文**：由`请求报文`和`响应报文`组成



**请求报文**：由`请求行`,`请求头`,`空行`,`请求体`四部分组成。

**响应报文**：由`状态行`、`响应头`、`空行`、`响应体`四部分组成

- **请求行**：包含http方法，请求地址，http协议以及版本
- **请求头/响应头**：`key:value`来告诉服务器，客户端需要哪些内容，要注意什么类型等
- **空行**：用来区分首部和实体，因为请求头都是`key:value`的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
- **请求体**：请求的参数
- **状态行**：包含http协议及版本、数字状态码、状态码英文名称
- **响应体**：服务端返回的数据

### HTTP请求方法

**HTTP1.0**： `GET`、`POST`、`HEAD`

**HTTP1.1：** `PUT`、`PATCH`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT`

| GET     | 获取资源                                    |
| ------- | ------------------------------------------- |
| POST    | 传输资源，通常会造成服务器资源的修改        |
| HEAD    | 获得报文首部                                |
| PUT     | 更新资源                                    |
| PATCH   | 对PUT的补充，对已知资源部分更新             |
| DELETE  | 删除资源                                    |
| OPTIONS | 列出请求资源支持的请求方法，用来跨域请求    |
| TRACE   | 追踪请求/响应路径，用于测试或诊断           |
| CONNECT | 将连接改为管道方式用于代理服务器(`隧道代理) |

### GET和POST的区别

- `GET`在浏览器回退时是无害的，而`POST`会再次发起请求
- `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置
- `GET`请求参数会被保留在浏览器历史记录里，而`POST`中的参数不会被保留
- `GET`请求在`URL`中传递的参数有长度限制(浏览器限制大小不同)，而`POST`没有限制
- `GET`参数通过`URL`传递，`POST`放在`Request body`中
- `GET`没有`POST`安全，因为`GET`请求参数直接暴露在`URL`上，所以不能用来传递敏感信息

### HTTP状态码

- **1xx: 指示信息——表示请求已接收，继续处理**
- **2xx: 成功——表示请求已被成功接收**
- **3xx: 重定向——表示要完成请求必须进行进一步操作**
- **4xx: 客户端错误——表示请求有语法错误或请求无法实现**
- **5xx: 服务端错误——表示服务器未能实现合法的请求**

常见状态码：

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 请求成功                                                     |
| 206    | 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时 |
| 301    | 永久重定向                                                   |
| 302    | 临时重定向                                                   |
| 304    | 请求资源未修改，可以使用缓存的资源，不用在服务器取           |
| 400    | 请求有语法错误                                               |
| 401    | 没有权限访问                                                 |
| 403    | 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时 |
| 404    | 请求资源不存在                                               |
| 500    | 服务器内部错误，无法完成请求                                 |
| 503    | 请求未完成，因服务器过载、宕机或维护等                       |

### 持久连接/长连接

`http1.0`协议采用的是“请求-应答”模式，当使用普通模式时，**每个请求/应答**服务器和客户端都要**新建一个连接**，完成之后立即断开连接(`http`协议为`无连接`的协议)

`http1.1`版本支持**长连接**，即请求头添加`Connection: Keep-Alive`，使用Keep-Alive模式(又称持久连接，连接复用)建立一个`TCP`连接后使客户端到服务端的连接持续有效，可以发送/接受多个`http`请求/响应，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接

#### 如何避免长连接资源浪费？

- **客户端请求头声明**：`Connection: close`，本次通信后就关闭连接
- **服务端配置**： 如Nginx， **设置`keepalive_timeout`设置长连接超时时间，`keepalive_requests`设置长连接请求次数上限**

### 管道化引起的对头阻塞问题

`管理化`连接的消息如下：

> 请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3

如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题`队头堵塞`

#### 并发连接

因为一个域名允许分配多个长连接，就相当于**增加了任务队列**，不至于一个队列里的任务阻塞了其他全部任务。现在的浏览器标准中一个域名`并发连接`可以有`6~8`个，记住是6~8个，不是6个(**Chrome6个/Firefox8个**)

#### 域名分片

比如a.baidu.com，b.baidu.com，c.baidu.com，多准备几个`二级域名`，当我们访问baidu.com时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器

而在`HTTP2.0`下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个TCP连接中发送多个请求

### HTTP代理

#### 普通代理（中间人代理）

![image-20211206210304983](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211206210304983.png)

代理服务器相当于一个中间人，可以帮服务器和客户端**过滤、缓存、负载均衡**(多台服务器共用一台代理情况下)等一些处理

#### 隧道代理

客户端通过`CONNECT`方法请求隧道代理创建一个可以到任意目标服务器和端口号的TCP连接，创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理

![image-20211206213617434](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211206213617434.png)

为什么需要隧道代理呢？

我们都知道`https`服务是需要网站有证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建`TLS`，所以就有了隧道代理，它把浏览器的数据原样透传，这样就实现了通过中间代理和服务端进行TLS握手，然后进行加密传输

- **突破访问限制**：如访问一些单位或集团内部资源，或用国外代理服务器(翻墙)
- **安全性更高**：上网者可以通过这种方式隐藏自己的IP，免受攻击。还可以对数据过滤，对非法IP限流等
- **负载均衡**：
- **缓存代理**：

### HTTP 2.0

- 使用新的`二进制协议`，不再是纯文本，避免文本歧义，缩小了请求体积
- `多路复用`，同域名下所有通信都是在单链接(双向数据流)完成，提高连接的复用率，在拥塞控制方面有更好的能力提升
- 使用`HPACK算法将头部压缩`，用`哈夫曼编码`建立索表，传送索引大大节约了带宽
- 允许`服务端主动推送`数据给客户端

## HTTPS

**HTTPS = HTTP + SSL / TLS**

TLS是SSL的升级版，而且TLS1.2版本以下都已废弃，目前主要用的是`TLS 1.2`和`TLS 1.3`。而**OpenSSL**则是**开源版本**的

![image-20211206231231861](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211206231231861.png)

- **`RSA`**：表示握手时用RSA算法交换密钥

- **`PSK`**：表示使用PSK算法签名
- **`AES128-GCM`**：表示使用AES256对称加密算法通信，密钥长度128，分组模式GCM。TLS 1.3中只剩下称加密算法有**AES**和**CHACHA20**，分组模式只剩下**GCM**和**POLY1305**

- **`SHA256`**：表示使用SHA256算法验证信息完整性并生成随机数。TLS 1.3中哈希摘要算法只剩下**SHA256**和**SHA384**

![image-20211205174318153](https://cdn.jsdelivr.net/gh/TaoCesc/blogImages/imgs/image-20211205174318153.png)

1. 客户端请求HTTPS网址，然后连接到**服务器的443端口**（HTTPS默认端口，类似于HTTP的80端口）
2. 采用HTTPS协议的服务器有一套数字**CA（Certification Authority）证书**，证书需要申请，并由专门的数字证书认证机构（CA）通过审核后颁发的电子证书。颁发证书的同时会**产生一个私钥和公钥**。私钥由服务端自己保存，不可以泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器相应客户端请求，将证书传递给客户端，证书包含公钥和其他信息。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

> 如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码KEY，并使用公钥A将其加密。

5. 服务器把加密后的随机码KEY发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码KEY之后会使用私钥B将其解密。
7. 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。

> HTTPS 相比 HTTP最大的不同就是多了一层 SSL (Secure Sockets Layer 安全套接层)或 TLS (Transport Layer Security 安全传输层协议)。有了这个安全层，就确保了互联网上通信双方的通信安全

### SSL / TLS 握手详细过程

1. **"client hello"消息：** 客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。

2. **"server hello"消息：** 服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。

3. 验证：

    客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：

   1. 检查数字签名
   2. 验证证书链 (这个概念下面会进行说明)
   3. 检查证书的有效期
   4. 检查证书的撤回状态 (撤回代表证书已失效)

4. **"premaster secret"字符串：** 客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。

5. **使用私钥：** 服务器使用私钥解密"premaster secret"。

6. **生成共享密钥：** 客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 **KEY**。

7. **客户端就绪：** 客户端发送经过共享密钥 **KEY**加密过的"finished"信号。

8. **服务器就绪：** 服务器发送经过共享密钥 **KEY**加密过的"finished"信号。

9. **达成安全通信：** 握手完成，双方使用对称加密进行安全通信。

## 输入一串URL服务器如何工作

### DNS解析域名的实际IP地址

发送至DNS服务器并获得域名对应的WEB服务器的ip地址。

DNS解析首先会从**浏览器的缓存**中去寻找是否有这个网址的IP地址，如果没有就向**OS系统**中的DNS缓存中寻找，如果没有就去**路由器**的DNS缓存，如果没有就是**ISP**的DNS缓存中寻找。

**浏览器 -> 系统 -> 路由器 -> ISP**

### 检查浏览器是否有缓存

1. 通过`Cache-Control`和`Expires`来检查是否命中强缓存，命中则直接取本地磁盘的html（状态码为200 from disk(or memory) cache，内存or磁盘）
2. 如果没有命中强缓存，则会向服务器发起请求（服务器通过`Etag`和`Last-Modify`来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；
3. 若强缓存和协商缓存都没有命中则返回请求结果。

### 与WEB服务器建立TCP连接

TCP协议通过**三次握手**建立连接

- 客户端通过`SYN`报文段发送连接请求，确定服务器是否开启端口准备连接。状态设置为`SYN_SEND`
- 服务器如果有开着的端口并且决定接受连接，则会返回一个`SYN+ACK`报文段给客户端，状态设置为`SYN_RECV`
- 客户端收到服务器的`SYN+ACK`报文段，向服务器发送`ACK`报文段表示确认。此时客户端和服务器都设置为 `ESTABLISHED` 状态。**连接建立**，可以开始数据传输了。

### 若协议是https则会做加密

> HTTPS = HTTP + 加密 + 认证 + 完整性保护

1. 首先申请**CA证书**，并安装在服务器上（一个文件，配置nginx支持监听443端口开启ssl并设置证书路径）
2. 浏览器发送请求
3. 网站从浏览器发过来的加密规则中选一组自身也支持的**加密算法和hash算法**，并向浏览器发送带有公钥的证书，证书还包含（网站地址、证书颁发机构、过期时间）
4. 浏览器解析证书
   - **验证证书的合法性**。如颁发机构是否合法、证书中的网站地址是否与访问的地址一致，若不合法，则浏览器提示证书不受信任，若合法，浏览器会显示一个小锁头。
   - 若合法，或用户接受了不合法的证书，浏览器会生成一串随机数的密码（**即密钥**）,并用**证书中提供的公钥加密**。
   - 使用约定好的hash计算握手信息，并使用**密钥**对消息进行加密，最后将之前生成的所有消息一并发送给网站服务器。
5. 网站服务器解析消息。**用已有的私钥将密钥解密出来**，然后用密钥解密出来的握手信息，并验证是否跟浏览器传过来的一致。然后再用密钥加密一段握手消息，发送给浏览器。
6. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时**握手过程结束**，之后所有的通信数据将由之前浏览器生成的随机密码并利用**对称加密算法进行加密**。

### 浏览器发送请求获取页面html

浏览器向WEB服务器的ip地址发送响应的http get请求页面html。

通常的请求行是： 请求的方式（`get`或`post`）+请求的资源的位置`(url) + HTTP/[版本号](HTTP/1.1)`.

发起http请求的过程主要是组装http报文并将报文发向指定地址的过程。

### 服务器响应html

这里的服务器可能是`server`或者是`cdn`

> cdn - 内容分发网络，可用来加快传输速度，主要用来存储静态文件，例如前端的html、css、js、图片文件等。

### 浏览器解析html

- 浏览器下载html数据，将html文档解析成为一个个`标签`,这些标签组成了`树状结构`
- 如果解析到`style`标签则开始解析css，如果解析到link标签则先异步下载，完成后解析css。
- 如果遇到`script`标签，判断是行内写法则直接解析执行，如果是src引入则`同步下载`脚本文件，下载完成`立即执行`，注意这里下载过程是`阻塞`的，其他流程都会等下载完成后执行。

### 浏览器渲染页面

### 浏览器解析执行js脚本

这个过程中可能会有dom操作、ajax发起的http网络请求等。

### 浏览器发起网络请求

### 服务器响应ajax请求

### 浏览器处理事件循环等异步逻辑。
